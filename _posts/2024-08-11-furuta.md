---
layout: post
title: Real-life Reinforcement Learning - Furuta Pendulum
subtitle: Building and training an inverted pendulum robot
thumbnail-img: /assets/img/furuta/thumb.png
share-img: /assets/img/furuta/thumb.png
category: project
tags: [SAC, reinforcement-learning, AI, robotics]
---

![](/assets/img/furuta/robot.gif)

### [Link](https://github.com/energy-in-joles/Inverted-Pendulum-Robot) to Project Repository ###

# Contents
- [Introduction](#introduction)
- [Robot Design](#robot-design)
- [Robot Environment](#robot-environment)
- [RL Model](#reinforcement-learning-model)

# Introduction
<!-- begin_excerpt -->
A few months ago, I chanced upon a [video](https://vt.tiktok.com/ZS2BTrx5T/) that demonstrated a commercial Furuta Pendulum design used to teach control theory at the University level. As someone who is always itching to try a new reinforcement learning (RL) project, this felt like the perfect challenge to apply RL to a hardware system from scratch!
<!-- end_excerpt -->

## What is it?
![explain](/assets/img/furuta/explain.jpg){: .mx-auto.d-block :}
A Furuta Pendulum is a control problem which involves a pendulum that swings in the vertical plane (as annotated with red arrows above) driven by a motor shaft in the horizontal plane (as annotated with blue arrows). The goal of the robot is to swing the pendulum to the upright vertical position (an inverted pendulum) and to keep it balanced in that position for as long as possible.

## Project Overview

This project involved building the hardware and software compoents of the robot from scratch and integrating them into one coherent system. The project can largely be split into 3 major design components:
1. **Robot Design**: The physical hardware of the robot and the Arduino code for sending the robot's raw motor and pendulum positions, while receiving and executing control instructions from the PC.
2. **Robot Environment**: The environment that the RL model interacts with to control the robot. This "middleman" between the robot and model serves to translate the raw data sent between the two to ensure that the interaction is seamless.
3. **RL Model**: The model makes the control decisions for the robot and seeks to optimise the reward calculated by the environment by continuously fine tuning its policy.

# Robot Design

## Hardware Design

![cad](/assets/img/furuta/cad.png){: .mx-auto.d-block :}

Visit my [repo](https://github.com/energy-in-joles/Inverted-Pendulum-Robot?tab=readme-ov-file#hardware-implementation) to view the parts list for this project and to see the Fusion 360 CAD design.

The hardware design for this project was fairly straightforward. The robot was essentially just a rotary encoder cleverly connected to a motor using rigid couplers and 3D printed parts. However, since this was a very complex control problem, it was important that the robot could achieve precise movements and report accurate positioning data.

#### Motor

I decided on a stepper motor, as it provides a high precision and high torque solution. A stepper motor was chosen in favor over a servo, simply due to cost (especially for a servo that can rotate 360&deg;).

An average stepper motor provides a step resolution of around 1.8&deg;. However, I set the motor on a [quarter-step](https://www.automate.org/motion-control/case-studies/what-is-the-difference-between-full-stepping-the-half-stepping-and-the-micro-drive) setting to get a step resolution of around 0.45&deg;. 

The stepper motor also allowed me to consistently return the robot to a home position. This was critical for resetting the robot environment after each training epsiode.

#### Rotary Encoder

A broad [distinction](https://www.usdigital.com/blog/difference-incremental-vs-absolute-encoders/#:~:text=An%20incremental%20encoder%20can%20only,exact%20position%20without%20any%20movement.) for rotary encoders is between incremental encoders and absolute encoders. Incremental encoders measure the change in position, rather than reporting the actual absolute position.

I found much cheaper high precision incermental encoders online, and decided to work with them. Incremental encoders allowed me to accurately report angular velocity (since it measures change).

![quadrature](/assets/img/furuta/quadrature.png){: .mx-auto.d-block :}
__*Credit: dynapar.com (link below)*__{: .mx-auto.d-block :}

I also needed to know the direction of rotation, where I chose to use a [quadrature encoder](https://www.dynapar.com/technology/encoder_basics/quadrature_encoder/). The encoder type produces two signals (A and B), where the discrepancy between the two is used to discern the direction of rotation.

However, to accurately report position, the encoder had to be zeroed at the vertical down position before every run. 

## Control

#### Motor



# Creating the environment

The environment 